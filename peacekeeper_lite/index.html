<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>和平精英 Lite - 单文件版</title>
    <link rel="stylesheet" href="style.css">
    <script>
        // Global Error Handler
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.position = 'fixed';
            div.style.top = '0';
            div.style.left = '0';
            div.style.width = '100%';
            div.style.backgroundColor = 'rgba(255,0,0,0.8)';
            div.style.color = 'white';
            div.style.padding = '20px';
            div.style.zIndex = '9999';
            div.style.fontFamily = 'monospace';
            div.innerHTML = '<h3>Error Detected:</h3>' + msg + '<br>Line: ' + line + '<br>' + (error ? error.stack : '');
            document.body.appendChild(div);
            return false;
        };
    </script>
</head>

<body>
    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="survivors-count">生存人数: <span id="alive-num">100</span></div>
        <div id="crosshair"></div>

        <!-- Minimap -->
        <canvas id="minimap" width="200" height="200"></canvas>

        <div style="display: flex; justify-content: space-between; align-items: flex-end; width: 100%;">
            <div class="hud-element">
                <div id="health-bar">
                    <div id="health-fill"></div>
                </div>
                <div style="margin-top: 5px;">生命值: <span id="hp-text">100</span></div>
            </div>
            <div class="hud-element" style="text-align: right;">
                <div id="weapon-name" style="font-size: 1.2em; font-weight: bold; margin-bottom: 5px;">P92</div>
                <div id="ammo-count">30 / 90</div>
            </div>
        </div>
    </div>

    <!-- 1. Load Global Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <!-- 2. Load PointerLockControls (Inline) -->
    <script>
        (function () {
            const _euler = new THREE.Euler(0, 0, 0, 'YXZ');
            const _vector = new THREE.Vector3();
            const _changeEvent = { type: 'change' };
            const _lockEvent = { type: 'lock' };
            const _unlockEvent = { type: 'unlock' };
            const _PI_2 = Math.PI / 2;

            class PointerLockControls extends THREE.EventDispatcher {
                constructor(camera, domElement) {
                    super();
                    if (domElement === undefined) {
                        console.warn('THREE.PointerLockControls: The second parameter "domElement" is now mandatory.');
                        domElement = document.body;
                    }
                    this.domElement = domElement;
                    this.isLocked = false;
                    this.minPolarAngle = 0;
                    this.maxPolarAngle = Math.PI;
                    const scope = this;
                    function onMouseMove(event) {
                        if (scope.isLocked === false) return;
                        const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                        const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                        _euler.setFromQuaternion(camera.quaternion);
                        _euler.y -= movementX * 0.002;
                        _euler.x -= movementY * 0.002;
                        _euler.x = Math.max(_PI_2 - scope.maxPolarAngle, Math.min(_PI_2 - scope.minPolarAngle, _euler.x));
                        camera.quaternion.setFromEuler(_euler);
                        scope.dispatchEvent(_changeEvent);
                    }
                    function onPointerlockChange() {
                        if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
                            scope.dispatchEvent(_lockEvent);
                            scope.isLocked = true;
                        } else {
                            scope.dispatchEvent(_unlockEvent);
                            scope.isLocked = false;
                        }
                    }
                    function onPointerlockError() {
                        console.error('THREE.PointerLockControls: Unable to use Pointer Lock API');
                    }
                    this.connect = function () {
                        scope.domElement.ownerDocument.addEventListener('mousemove', onMouseMove);
                        scope.domElement.ownerDocument.addEventListener('pointerlockchange', onPointerlockChange);
                        scope.domElement.ownerDocument.addEventListener('pointerlockerror', onPointerlockError);
                    };
                    this.disconnect = function () {
                        scope.domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);
                        scope.domElement.ownerDocument.removeEventListener('pointerlockchange', onPointerlockChange);
                        scope.domElement.ownerDocument.removeEventListener('pointerlockerror', onPointerlockError);
                    };
                    this.dispose = function () { this.disconnect(); };
                    this.getObject = function () { return camera; };
                    this.getDirection = function () {
                        const direction = new THREE.Vector3(0, 0, - 1);
                        return function (v) { return v.copy(direction).applyQuaternion(camera.quaternion); };
                    }();
                    this.moveForward = function (distance) {
                        _vector.setFromMatrixColumn(camera.matrix, 0);
                        _vector.crossVectors(camera.up, _vector);
                        camera.position.addScaledVector(_vector, distance);
                    };
                    this.moveRight = function (distance) {
                        _vector.setFromMatrixColumn(camera.matrix, 0);
                        camera.position.addScaledVector(_vector, distance);
                    };
                    this.lock = function () { this.domElement.requestPointerLock(); };
                    this.unlock = function () { scope.domElement.ownerDocument.exitPointerLock(); };
                    this.connect();
                }
            }
            THREE.PointerLockControls = PointerLockControls;
        })();
    </script>

    <!-- 3. Main Game Logic (Inline) -->
    <script>
        try {
            // Check THREE
            if (typeof THREE === 'undefined') {
                throw new Error("Three.js library not loaded! Check internet connection.");
            }

            // --- Constants ---
            const PLAYER_HEIGHT = 1.8;
            const MOVEMENT_SPEED = 10.0;
            const JUMP_FORCE = 15;

            // --- Weapon Database (23 Weapons) ---
            const WEAPONS = {
                // Pistols
                'P92': { name: 'P92', damage: 15, range: 50, rate: 400, color: 0x888888 },
                'P1911': { name: 'P1911', damage: 18, range: 50, rate: 500, color: 0x888888 },
                'R1895': { name: 'R1895', damage: 25, range: 60, rate: 1000, color: 0x664422 },
                'P18C': { name: 'P18C', damage: 12, range: 40, rate: 100, color: 0x333333 },
                // Shotguns
                'S686': { name: 'S686', damage: 100, range: 20, rate: 200, color: 0x330000 },
                'S1897': { name: 'S1897', damage: 90, range: 25, rate: 800, color: 0x442222 },
                'S12K': { name: 'S12K', damage: 80, range: 25, rate: 300, color: 0x553333 },
                'DBS': { name: 'DBS', damage: 95, range: 20, rate: 400, color: 0x664444 },
                // SMGs
                'UZI': { name: 'Micro UZI', damage: 18, range: 80, rate: 80, color: 0x222222 },
                'UMP45': { name: 'UMP45', damage: 25, range: 100, rate: 150, color: 0x333333 },
                'Vector': { name: 'Vector', damage: 20, range: 70, rate: 60, color: 0x111111 },
                'Tommy': { name: 'Thompson', damage: 28, range: 90, rate: 120, color: 0x443333 },
                'Bizon': { name: 'PP-19 Bizon', damage: 22, range: 90, rate: 110, color: 0x223322 },
                // ARs
                'AKM': { name: 'AKM', damage: 35, range: 200, rate: 150, color: 0x552200 },
                'M16A4': { name: 'M16A4', damage: 30, range: 250, rate: 120, color: 0x222222 },
                'SCAR': { name: 'SCAR-L', damage: 31, range: 220, rate: 140, color: 0xCCA678 },
                'M416': { name: 'M416', damage: 31, range: 220, rate: 130, color: 0x333333 },
                'GROZA': { name: 'Groza', damage: 38, range: 180, rate: 110, color: 0x332222 },
                // Snipers / DMRs
                'Kar98k': { name: 'Kar98k', damage: 75, range: 500, rate: 1500, color: 0x663300 },
                'M24': { name: 'M24', damage: 85, range: 600, rate: 1600, color: 0x444444 },
                'AWM': { name: 'AWM', damage: 120, range: 800, rate: 2000, color: 0x004400 },
                'SKS': { name: 'SKS', damage: 45, range: 300, rate: 400, color: 0x554422 },
                'Mini14': { name: 'Mini14', damage: 40, range: 350, rate: 300, color: 0x444455 },
                // LMG
                'M249': { name: 'M249', damage: 32, range: 200, rate: 100, color: 0x444444 },
                'DP28': { name: 'DP-28', damage: 36, range: 200, rate: 180, color: 0x000000 },
            };

            // --- Global Variables ---
            let camera, scene, renderer;
            let controls;
            let raycaster;

            // Combat State
            let currentWeapon = WEAPONS['P92']; // Default weapon
            let lastShotTime = 0;

            // Movement state

            // Movement state
            const moveState = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                sprint: false
            };
            let canJump = false;
            let velocity = new THREE.Vector3();
            let direction = new THREE.Vector3();
            let prevTime = performance.now();

            // Game Objects
            const objects = [];
            const enemies = [];
            let playerHealth = 100;
            let ammo = 30;
            const maxAmmo = 90; // Fixed: maxAmmo was missing in variable declarations if not careful, good to ensure
            let score = 0;

            // Zone Variables
            let zoneRadius = 500;
            let zoneTargetRadius = 50;
            let zoneShrinkSpeed = 5;
            let zoneDamageTimer = 0;
            let zoneMesh;

            // Particles
            const particles = [];

            // Loot
            const lootItems = [];
            const LOOT_TYPES = {
                AMMO: 'ammo',
                HEALTH: 'health'
            };

            // --- Initialization ---
            init();
            animate();

            function init() {
                console.log("Initializing Game...");

                // 1. Scene Setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                scene.fog = new THREE.Fog(0x87CEEB, 0, 750);

                // 2. Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.y = PLAYER_HEIGHT;

                // 3. Lighting (SAFE MODE: High Intensity Ambient)
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(50, 200, 100);
                // Shadow disabled for Safe Mode to prevent black screen issues
                // dirLight.castShadow = true; 
                scene.add(dirLight);

                // 4. Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); // alpha: false ensures background color
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                // renderer.shadowMap.enabled = true; // Disabled for Safe Mode
                document.getElementById('game-container').appendChild(renderer.domElement);

                // 5. Controls
                if (typeof THREE.PointerLockControls === 'undefined') {
                    throw new Error("PointerLockControls not loaded.");
                }
                controls = new THREE.PointerLockControls(camera, document.body);

                // Click event
                document.addEventListener('click', function () {
                    try {
                        controls.lock();
                    } catch (e) {
                        console.error("Lock error:", e);
                    }
                });

                scene.add(controls.getObject());

                // UI Text
                const startText = document.getElementById('start-prompt') || document.createElement('div');
                startText.id = 'start-prompt';
                startText.innerText = "点击屏幕开始游戏 / Click to Start";
                startText.style.position = 'absolute';
                startText.style.top = '50%';
                startText.style.left = '50%';
                startText.style.transform = 'translate(-50%, -50%)';
                startText.style.color = 'white';
                startText.style.fontSize = '30px';
                startText.style.fontWeight = 'bold';
                startText.style.textShadow = '0 0 10px black';
                startText.style.pointerEvents = 'none';
                if (!document.getElementById('start-prompt')) document.body.appendChild(startText);

                controls.addEventListener('lock', function () { startText.style.display = 'none'; });
                controls.addEventListener('unlock', function () { startText.style.display = 'block'; });

                // 6. Environment (SAFE MODE: BasicMaterial)
                const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
                floorGeometry.rotateX(-Math.PI / 2);

                // Use MeshBasicMaterial to guarantee it is visible regardless of lighting
                const floorMaterial = new THREE.MeshBasicMaterial({
                    color: 0x444444,
                    wireframe: false
                });

                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                // floor.receiveShadow = true; 
                scene.add(floor);

                // Simple buildings
                const boxGeometry = new THREE.BoxGeometry(20, 20, 20);
                const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 }); // Safe Mode

                for (let i = 0; i < 50; i++) {
                    const box = new THREE.Mesh(boxGeometry, boxMaterial);
                    box.position.x = Math.floor(Math.random() * 20 - 10) * 20;
                    box.position.y = 10;
                    box.position.z = Math.floor(Math.random() * 20 - 10) * 20;
                    // box.castShadow = true;
                    // box.receiveShadow = true;
                    scene.add(box);
                    objects.push(box);
                }

                // Spawn Loot
                spawnLoot(15);
                spawnWeapons(20);

                // 7. Event Listeners
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                window.addEventListener('resize', onWindowResize);

                // Raycaster
                raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 100);

                // Spawn Enemies
                spawnEnemies(20);

                // Shooting
                document.addEventListener('mousedown', function (event) {
                    if (controls.isLocked) {
                        shoot();
                    }
                });

                console.log("Init complete. Scene has " + scene.children.length + " objects.");
            }

            function spawnEnemies(count) {
                const enemyGeometry = new THREE.BoxGeometry(2, 4, 2);
                const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Safe Mode

                for (let i = 0; i < count; i++) {
                    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    const x = Math.floor(Math.random() * 200 - 100) * 10;
                    const z = Math.floor(Math.random() * 200 - 100) * 10;
                    enemy.position.set(x, 2, z);

                    enemy.userData = {
                        health: 100,
                        speed: 5 + Math.random() * 5,
                        lastShot: 0,
                        shootRate: 2000 + Math.random() * 2000
                    };

                    scene.add(enemy);
                    enemies.push(enemy);
                    objects.push(enemy);
                }
                updateHUD();

                // Create Zone Visuals
                const zoneGeo = new THREE.CylinderGeometry(zoneRadius, zoneRadius, 500, 32, 1, true);
                const zoneMat = new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                zoneMesh = new THREE.Mesh(zoneGeo, zoneMat);
                zoneMesh.position.y = 0;
                scene.add(zoneMesh);
            }

            function spawnLoot(count) {
                const boxGeo = new THREE.BoxGeometry(1, 1, 1);

                for (let i = 0; i < count; i++) {
                    const type = Math.random() > 0.5 ? LOOT_TYPES.AMMO : LOOT_TYPES.HEALTH;
                    const color = type === LOOT_TYPES.AMMO ? 0x00ff00 : 0xffffff;

                    const material = new THREE.MeshBasicMaterial({ color: color }); // Safe Mode

                    const loot = new THREE.Mesh(boxGeo, material);

                    const x = Math.floor(Math.random() * 200 - 100) * 10;
                    const z = Math.floor(Math.random() * 200 - 100) * 10;
                    loot.position.set(x, 0.5, z);

                    loot.userData = { type: type };
                    loot.userData.rotSpeed = Math.random() * 2 + 1;

                    scene.add(loot);
                    lootItems.push(loot);
                }
            }

            function spawnWeapons(count) {
                const weaponKeys = Object.keys(WEAPONS);
                const geo = new THREE.CylinderGeometry(0.5, 0.5, 2, 8); // Distinct shape

                for (let i = 0; i < count; i++) {
                    const key = weaponKeys[Math.floor(Math.random() * weaponKeys.length)];
                    const weaponData = WEAPONS[key];

                    const mat = new THREE.MeshBasicMaterial({ color: weaponData.color });
                    const mesh = new THREE.Mesh(geo, mat);

                    const x = Math.floor(Math.random() * 200 - 100) * 10;
                    const z = Math.floor(Math.random() * 200 - 100) * 10;
                    mesh.position.set(x, 1, z); // Floating slightly higher

                    mesh.userData = {
                        type: 'weapon',
                        key: key,
                        rotSpeed: 2
                    };

                    scene.add(mesh);
                    lootItems.push(mesh); // Add to lootItems to be updated/rotated
                }
            }

            function shoot() {

                const now = performance.now();
                if (now - lastShotTime < currentWeapon.rate) return;
                lastShotTime = now;

                if (ammo <= 0) {
                    // Click sound or message?
                    return;
                }

                ammo--;
                updateHUD();

                createMuzzleFlash();

                raycaster.far = currentWeapon.range; // Set range based on weapon
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

                const intersects = raycaster.intersectObjects(objects);

                if (intersects.length > 0) {
                    const hitObject = intersects[0].object;
                    if (enemies.includes(hitObject)) {
                        hitObject.material.color.setHex(0xffffff);
                        setTimeout(() => {
                            if (enemies.includes(hitObject)) hitObject.material.color.setHex(0xff0000);
                        }, 100);

                        hitObject.userData.health -= currentWeapon.damage; // Use weapon damage 

                        if (hitObject.userData.health <= 0) {
                            scene.remove(hitObject);
                            enemies.splice(enemies.indexOf(hitObject), 1);
                            objects.splice(objects.indexOf(hitObject), 1);

                            createExplosion(hitObject.position, 0xff0000);

                            score++;
                            document.getElementById('survivors-count').innerText = "生存人数: " + (enemies.length + 1);

                            if (enemies.length === 0) {
                                alert("大吉大利，今晚吃鸡！你消灭了所有人。");
                                location.reload();
                            }
                        }
                    }
                }
            }

            function updateHUD() {
                document.getElementById('weapon-name').innerText = currentWeapon.name;
                document.getElementById('ammo-count').innerText = ammo + " / " + maxAmmo;
                document.getElementById('hp-text').innerText = playerHealth;
                document.getElementById('health-fill').style.width = playerHealth + "%";
            }

            function onKeyDown(event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveState.forward = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveState.left = true;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveState.backward = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveState.right = true;
                        break;
                    case 'Space':
                        if (canJump === true) velocity.y += JUMP_FORCE;
                        canJump = false;
                        break;
                    case 'ShiftLeft':
                        moveState.sprint = true;
                        break;
                }
            }

            function onKeyUp(event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveState.forward = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveState.left = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveState.backward = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveState.right = false;
                        break;
                    case 'ShiftLeft':
                        moveState.sprint = false;
                        break;
                }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                requestAnimationFrame(animate);

                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                if (controls.isLocked === true) {
                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;
                    velocity.y -= 9.8 * 10.0 * delta;

                    direction.z = Number(moveState.forward) - Number(moveState.backward);
                    direction.x = Number(moveState.right) - Number(moveState.left);
                    direction.normalize();

                    if (moveState.forward || moveState.backward) velocity.z -= direction.z * 400.0 * delta;
                    if (moveState.left || moveState.right) velocity.x -= direction.x * 400.0 * delta;

                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);

                    controls.getObject().position.y += (velocity.y * delta);

                    if (controls.getObject().position.y < PLAYER_HEIGHT) {
                        velocity.y = 0;
                        controls.getObject().position.y = PLAYER_HEIGHT;
                        canJump = true;
                    }
                }

                updateEnemies(time);
                updateZone(delta);
                updateLoot(delta);
                updateParticles(delta);
                updateMinimap();

                prevTime = time;

                renderer.render(scene, camera);
            }

            function updateEnemies(time) {
                const playerPos = controls.getObject().position;

                enemies.forEach(enemy => {
                    const dist = enemy.position.distanceTo(playerPos);
                    const engageDistance = 30;

                    if (dist < 100 && dist > engageDistance) {
                        const dir = new THREE.Vector3().subVectors(playerPos, enemy.position).normalize();
                        dir.y = 0;
                        enemy.position.add(dir.multiplyScalar(enemy.userData.speed * 0.01));
                        enemy.lookAt(playerPos);
                    } else if (dist <= engageDistance) {
                        enemy.lookAt(playerPos);
                        if (time - enemy.userData.lastShot > enemy.userData.shootRate) {
                            enemy.userData.lastShot = time;
                            enemyShoot(enemy, playerPos);
                        }
                    }
                });
            }

            function enemyShoot(enemy, targetPos) {
                const tracerGeo = new THREE.BufferGeometry().setFromPoints([
                    enemy.position,
                    new THREE.Vector3(targetPos.x, targetPos.y - 0.5, targetPos.z)
                ]);
                const tracerMat = new THREE.LineBasicMaterial({ color: 0xff0000 });
                const tracer = new THREE.Line(tracerGeo, tracerMat);
                scene.add(tracer);

                setTimeout(() => {
                    scene.remove(tracer);
                    tracer.geometry.dispose();
                    tracer.material.dispose();
                }, 100);

                if (Math.random() < 0.4) {
                    playerHealth -= 10;
                    if (playerHealth < 0) playerHealth = 0;
                    updateHUD();

                    const flash = document.createElement('div');
                    flash.className = 'damage-flash';
                    flash.style.position = 'absolute';
                    flash.style.top = '0';
                    flash.style.left = '0';
                    flash.style.width = '100%';
                    flash.style.height = '100%';
                    flash.style.pointerEvents = 'none';
                    document.body.appendChild(flash);
                    setTimeout(() => flash.remove(), 200);

                    if (playerHealth === 0) {
                        alert("游戏结束！剩余人数: " + enemies.length);
                        location.reload();
                    }
                }
            }

            function updateZone(delta) {
                if (!delta) return;
                if (zoneRadius > zoneTargetRadius) {
                    zoneRadius -= zoneShrinkSpeed * delta;
                    if (zoneRadius < zoneTargetRadius) zoneRadius = zoneTargetRadius;
                    zoneMesh.scale.set(zoneRadius / 500, 1, zoneRadius / 500);
                }

                const playerDist = controls.getObject().position.distanceTo(new THREE.Vector3(0, controls.getObject().position.y, 0));

                if (playerDist > zoneRadius) {
                    zoneDamageTimer += delta;
                    if (zoneDamageTimer > 1.0) {
                        playerHealth -= 5;
                        if (playerHealth < 0) playerHealth = 0;
                        updateHUD();

                        const flash = document.createElement('div');
                        flash.className = 'damage-flash';
                        flash.style.backgroundColor = 'rgba(0, 0, 255, 0.3)';
                        flash.style.position = 'absolute';
                        flash.style.top = '0';
                        flash.style.left = '0';
                        flash.style.width = '100%';
                        flash.style.height = '100%';
                        flash.style.pointerEvents = 'none';
                        document.body.appendChild(flash);
                        setTimeout(() => flash.remove(), 200);

                        if (playerHealth === 0) {
                            alert("你倒在了信号接收区外！剩余人数: " + enemies.length);
                            location.reload();
                        }
                        zoneDamageTimer = 0;
                    }
                } else {
                    zoneDamageTimer = 0;
                }
            }

            function updateLoot(delta) {
                if (!delta) return;
                const playerPos = controls.getObject().position;

                for (let i = lootItems.length - 1; i >= 0; i--) {
                    const loot = lootItems[i];
                    loot.rotation.y += delta * loot.userData.rotSpeed;

                    if (loot.position.distanceTo(playerPos) < 2.5) {
                        if (loot.userData.type === 'weapon') {
                            // Pick up weapon
                            currentWeapon = WEAPONS[loot.userData.key];
                            createExplosion(loot.position, 0xffff00); // Yellow flash
                            scene.remove(loot);
                            lootItems.splice(i, 1);
                            updateHUD();

                            // Optional: Toast message
                            const toast = document.createElement('div');
                            toast.innerText = "已装备: " + currentWeapon.name;
                            toast.style.position = 'fixed';
                            toast.style.bottom = '100px';
                            toast.style.left = '50%';
                            toast.style.transform = 'translate(-50%, 0)';
                            toast.style.color = '#ffcc00';
                            toast.style.fontSize = '20px';
                            toast.style.fontWeight = 'bold';
                            toast.style.textShadow = '1px 1px 2px black';
                            document.body.appendChild(toast);
                            setTimeout(() => toast.remove(), 2000);

                        } else if (loot.userData.type === LOOT_TYPES.AMMO) {
                            if (ammo < maxAmmo) {
                                ammo = Math.min(ammo + 30, maxAmmo);
                                createExplosion(loot.position, 0x00ff00);
                                scene.remove(loot);
                                lootItems.splice(i, 1);
                                updateHUD();
                            }
                        } else if (loot.userData.type === LOOT_TYPES.HEALTH) {
                            if (playerHealth < 100) {
                                playerHealth = Math.min(playerHealth + 50, 100);
                                createExplosion(loot.position, 0xff0000);
                                scene.remove(loot);
                                lootItems.splice(i, 1);
                                updateHUD();
                            }
                        }
                    }
                }
            }

            function createMuzzleFlash() {
                const flashGeo = new THREE.PlaneGeometry(0.5, 0.5);
                const flashMat = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeo, flashMat);

                flash.position.set(0.5, -0.5, -1);
                camera.add(flash);

                setTimeout(() => {
                    camera.remove(flash);
                    flash.geometry.dispose();
                    flash.material.dispose();
                }, 50);
            }

            function createExplosion(position, color) {
                const particleCount = 20;
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material = new THREE.MeshBasicMaterial({ color: color });

                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);

                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );
                    particle.userData.life = 1.0;

                    scene.add(particle);
                    particles.push(particle);
                }
            }

            function updateParticles(delta) {
                if (!delta) return;
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.userData.life -= delta;
                    p.position.addScaledVector(p.userData.velocity, delta);
                    p.userData.velocity.y -= 9.8 * delta;

                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        particles.splice(i, 1);
                    } else {
                        p.scale.setScalar(p.userData.life);
                    }
                }
            }

            function updateMinimap() {
                const canvas = document.getElementById('minimap');
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                const mapScale = width / 1000;
                const centerX = width / 2;
                const centerY = height / 2;

                ctx.clearRect(0, 0, width, height);

                ctx.beginPath();
                ctx.arc(centerX, centerY, zoneRadius * mapScale, 0, 2 * Math.PI);
                ctx.strokeStyle = '#0000ff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'rgba(0, 0, 255, 0.1)';
                ctx.fill();

                ctx.fillStyle = 'red';
                enemies.forEach(enemy => {
                    const x = centerX + enemy.position.x * mapScale;
                    const y = centerY + enemy.position.z * mapScale;

                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });

                lootItems.forEach(loot => {
                    ctx.fillStyle = loot.userData.type === LOOT_TYPES.AMMO ? '#00ff00' : '#ffffff';
                    const x = centerX + loot.position.x * mapScale;
                    const y = centerY + loot.position.z * mapScale;

                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                });

                const playerPos = controls.getObject().position;
                const px = centerX + playerPos.x * mapScale;
                const py = centerY + playerPos.z * mapScale;

                ctx.save();
                ctx.translate(px, py);
                const cameraDir = new THREE.Vector3();
                camera.getWorldDirection(cameraDir);
                const angle = Math.atan2(cameraDir.x, cameraDir.z);

                ctx.rotate(angle);

                ctx.beginPath();
                ctx.moveTo(0, -6);
                ctx.lineTo(4, 4);
                ctx.lineTo(0, 2);
                ctx.lineTo(-4, 4);
                ctx.closePath();
                ctx.fillStyle = 'yellow';
                ctx.fill();
                ctx.restore();
            }

        } catch (error) {
            console.error(error);
            alert("游戏启动失败: " + error.message);

        }
    </script>
</body>

</html>